# Los l√≠mites de la interoperabilidad Elm/JS

Muchos lenguajes tienen una ‚Äúinterfaz de funciones for√°neas‚Äù (FFI por su sigla en ingl√©s) que te permite vincular directamente con funciones del lenguaje subyacente. Por ejemplo, Scala puede llamar funciones de Java directamente. Lo mismo ocurre con Clojure y Java, Python y C, Haskell y C, y muchos otros.

**Elm no tiene una interfaz de funciones for√°neas tradicional con JavaScript.** No es posible llamar funciones arbitrarias de JavaScript en cualquier momento. Es una limitaci√≥n que trae beneficios que mucha gente prefiere, pero no es para cualquiera. Si te encuentras evaluando si usar Elm con fines comerciales, te recomiendo que revises [estos ejemplos de interoperabilidad](https://github.com/elm-community/js-integration-examples) para saber si con flags, puertos y elementos personalizados tienes cubiertas tus necesidades.

<!-- TODO: üëÜ Agregar estos ejemplos al repositorio y traducirlos. -->

¬øPor qu√© Elm tom√≥ una decisi√≥n diferente en comparaci√≥n con otros lenguajes?

## Ventajas y desventajas

Los puertos son un caso at√≠pico en la historia de los lenguajes de programaci√≥n. Hay dos principales estrategias para la interoperabilidad, y Elm no adopt√≥ ninguna de ellas:

2. **Interfaz de funci√≥n for√°nea (FFI).** Permite crear v√≠nculos directos hacia funciones en el lenguaje subyacente. Por ejemplo, Scala puede llamar funciones de Java directamente. Lo mismo ocurre con Clojure y Java, Python y C, Haskell y C, y muchos otros. Esta tambi√©n es una estrategia que ha resultado ser muy efectiva.

Estos caminos son atractivos para facilitar un crecimiento r√°pido y tener m√°xima flexibilidad, pero no son ideales para Elm por dos razones:

1. **P√©rdida de garant√≠as.** Una de las mejores cosas sobre Elm es que hay categor√≠as enteras de problemas de las que simplemente no te tienes que preocupar. No hay excepciones sorpresa para capturar, y las funciones no pueden mutar datos en forma sorpresiva. Creo que este es el principal valor de Elm por sobre otras alternativas, pero si pudi√©ramos llamar c√≥digo JS directamente, todo se evapora. ¬øEste paquete produce excepciones en tiempo de ejecuci√≥n? ¬øCu√°ndo? ¬øMuta los valores que le paso? ¬øNecesito chequear? ¬øEl paquete produce efectos secundarios? ¬øSe comunica con servidores externos? ¬øEscribe passwords en sus logs? Un gran n√∫mero de usuarios de Elm tienen inter√©s en Elm justamente porque con el lenguaje no necesitan cubrirse las espaldas de esta manera.
2. **Avalancha de paquetes.** Hay una gran demanda de copias directas de interfaces de JavaScript hacia Elm. En los dos a√±os previos a que existiera `elm/html`, estoy seguro de que alguien hubiera escrito una interfaz para usar jQuery si fuera posible. Esto ya ha ocurrido con otros lenguajes funcionales tipados que compilan a JS, pero que tienen una estrategia m√°s tradicional de interoperabilidad. Hasta donde s√©, este tipo de situaci√≥n es m√°s o menos √∫nica en lenguajes que compilan a JS. No existe esa presi√≥n en Python, por ejemplo, as√≠ que probablemente es un problema producto de la cultura e historia del ecosistema de JavaScript en espec√≠fico.

Dados estos problemas, los puertos y los elementos personalizados son atractivos porque nos permiten lograr cosas usando JavaScript, sin sacrificar los beneficios de Elm. Ideal. Pero por otro lado, tambi√©n significa que Elm no puede simplemente colgarse del ecosistema JavaScript para ganar en librer√≠as m√°s r√°pidamente. Si adoptamos una visi√≥n m√°s a largo plazo, creo que es una buena estrategia. Como consecuencia:

1. **Los paquetes est√°n dise√±ados para Elm.** Mientras la comunidad de Elm adquiere experiencia y confianza, empezamos a ver nuevas y propositivas estrategias para enfrentar la diagramaci√≥n y la visualizaci√≥n de datos que se acoplan perfectamente con la Arquitectura Elm y con el ecosistema en general. Anticipo que esto se repetir√° con muchos otros problemas.
2. **El c√≥digo es port√°til.** Si Elm llegara un d√≠a a compilar a x86 o WebAssembly, todo el ecosistema seguir√≠a funcionando, ¬°pero m√°s r√°pido! Los puertos garantizan que todos los paquetes est√©n escritos completamente en Elm, y el lenguaje mismo est√° dise√±ado para que nuevos destinos de compilaci√≥n sean viables.
3. **Los paquetes son m√°s seguros.** Lenguajes como JavaScript tienen serios problemas de seguridad con sus paquetes. No es infrecuente oir noticias sobre [robo de credenciales](https://www.bleepingcomputer.com/news/security/compromised-javascript-package-caught-stealing-npm-credentials/) o [de llaves de API](https://winbuzzer.com/2020/01/14/microsoft-discovers-an-npm-package-thats-been-stealing-unix-user-data-xcxwbn/), y esto causa un costo permanente en auditor√≠a de todos estos paquetes. Es hasta posible instalar un [keylogger](https://es.wikipedia.org/wiki/Keylogger) en `window`. Los paquetes de Elm garantizan que categor√≠as completas de vulnerabilidades simplemente no pueden ser explotadas, lo que reduce el costo de la auditor√≠a y los riesgos de seguridad en general.
4. **Es m√°s f√°cil de optimizar.** El estilo del c√≥digo generado ha cambiado considerablemente de versi√≥n a versi√≥n. Por ejemplo, en la [versi√≥n 0.19](https://elm-lang.org/news/small-assets-without-the-headache) pudimos reducir dram√°ticamente el tama√±o de los exportables (1) al generar c√≥digo que funciona mejor con los minificadores de JavaScript, y (2) al usar distintas maneras de representar tipos personalizados dependiendo del nivel de optimizaci√≥n elegido. Seguramente volveremos a hacer cambios para permitir la subdivisi√≥n de archivos o si encontramos una convenci√≥n de llamada m√°s r√°pida para las funciones currificadas. Adem√°s, el compilador puede asumir que todo el c√≥digo es puro, lo que le permite manipularlo mucho m√°s que otros compiladores. Si nos cas√°ramos con una convenci√≥n de llamada espec√≠fica har√≠a que muchas de estas optimizaciones sean imposibles.

Es un camino m√°s largo y arduo, pero los lenguajes pueden vivir mucho m√°s de 30 a√±os. Tienen que sostener a equipos y empresas por d√©cadas, y cuando pienso en c√≥mo ser√° Elm en 20 o 30 a√±os, las ventajas otorgadas por los puertos me permiten ser muy optimista. Mi charla [‚Äú¬øQu√© es el √©xito?‚Äù](https://youtu.be/uGlzRt-FYto) (en ingl√©s) empieza lenta, pero eventualmente toca este tema.

<!-- TODO: üëÜ ¬øProveer subt√≠tulos? -->

Y repito, este no es un camino para cualquiera. Hay muchos lenguajes alternativos que tienen una interfaz de funci√≥n for√°nea tradicional, y te sugiero que los investigues si crees que ser√≠an una mejor opci√≥n. ¬øEl ecosistema de paquetes es igual de coherente? ¬øTendr√°s m√°s excepciones en tiempo de ejecuci√≥n? Tal vez. Pero tal vez la flexibilidad vale la pena para ti. As√≠ que te animo a que revises [estos ejemplos de interoperabilidad](https://github.com/elm-community/js-integration-examples) para decidir si las flags, los puertos y los elementos personalizados cubren todas tus necesidades. Esto es especialmente importante si est√°s considerando usar Elm con fines comerciales.

<!-- TODO: üëÜ Agregar estos ejemplos al repositorio y traducirlos. -->
